# Практика 4: Компилятор и оптимизация

[![Feedback](feedback.png)][feedback_day4]

## Цели

__Цель данной работы__ — познакомиться с примером кода, незначительные изменения
которого оказывают существенное влияние на производительность. В частности, нам
предстоит увидеть на практическом примере, какие оптимизации помогают
компилятору генерировать более эффективный код, а какие — нет.

## Задачи

__Основные задачи__

  1. Закрепить навыки сбора и анализа метрик производительности, построенные
     вокруг инфраструктуры OpenCV (тесты производительности и скрипты).
  1. Оптимизировать функцию `ImageResize`, применяя разнообразные приемы
     "упрощения" кода при сохранении его корректности. При этом допускается
     расхождение с оригинальной версией в +/- 1 значение интенсивности пиксела.

__Дополнительные задачи__

  - При желании можно подумать над дополнительными оптимизациями, или вернуться
    к функции `GuoHallThinning`.

## Общая последовательность действий

В целом, порядок работы сегодня очень похож на предыдущий, то есть на третью
практику. Главное, чем предстоит заниматься — это оптимизировать функцию
`ImageResize`, которая является второй по продолжительности работы.

  1. Как и в предыдущий день, перед началом оптимизации необходимо осуществить
     некоторые предварительные действия:

     - Получить актуальную версию кодов из центрального репозитория (см.
       [инструкции][git-update]). Затем нужно собрать проект и проверить его
       работоспособность, запустив тесты и демо-приложение.

     - Далее нужно создать новую ветку в Git для выполнения практического
       задания. Изменения необходимо постоянно фиксировать в истории Git,
       выкладывая в рабочую ветку на GitHub и контролируя успешность
       тестирования на Travis-CI.

     - Запустить тесты производительности функции `ImageResize` и сохранить
       XML-файл с результатами. Этот файл в дальнейшем будет использован для
       сравнения производительности до и после оптимизации.

  1. Разобраться с алгоритмом `ImageResize` и оптимизировать его, используя
     следующие приемы:
     - Удаление недостижимого кода;
     - Вынос операций, не зависящих от итерации цикла за пределы цикла;
     - Изменение типов данных: `uchar` или `int`, `int` или `uint`, `float` или
       `double`  и т.д.;
     - "Небезопасное" переупорядочивание вычислений с плавающей запятой;
     - Использование знаний о возможных значениях аргументов для упрощения
       вычислений.

  1. Убедиться, что оптимизированная функция работает быстрее, чем оригинальный
     код. Проанализируйте ускорения, сравнивая отчеты о производительности до и
     после оптимизации.

## Детальная инструкция по выполнению работы

  1. Подробные инструкции по использованию `git` и измерению производительности
     могут быть найдены в описаниях предыдущих практических заданий
     ([Git][git-update], [сбор метрик][collect-metrics]).

  1. Рассматриваемая в данном практическом задании функция `ImageResize`
     реализует метод изменения размера изображения с использованием билинейной
     интерполяции. Изображение, полученное с использованием оптимизированной
     версии, должно в каждом пикселе отличаться от изображения, полученного с
     использованием исходной реализации, не более чем на 1. Обратите внимание,
     что тест на производительность обновлен с учетом данного допуска.

  1. Перечисленные ниже особенности могут быть полезны для оптимизации
     функции `ImageResize`:
     - Формулы вычисления координат могут быть преобразованы следующим образом:

       ```cpp
       const float x = (((float)col) + .5f) * sz_src.width  / sz.width  - .5f;
       ```

       ```cpp
       const float x = col * xscale + x0;
       ```

       , где `xscale` и `x0` — это floating-point константы, не зависящие от
       текущих координат.

     - Для неотрицательных значений `x` С++ выражения `(int)floor(x)` и
       `(int)(x)` приводят к одинаковому результату. Однако это не верно для `x
       < 0` и `x > (1<<31)`.

     - Билинейная интерполяция не выводит значения за пределы диапазона значений
       исходных данных. То есть если исходные данные принадлежат диапазону `0 <=
       value <= 255`, то и результат интерполяции принадлежит диапазону `[0,
       255]` для любых возможных комбинаций значений исходных данных.

     - При уменьшении изображения, вычисленные координаты пикселей исходного
       изображения всегда находятся в пределах изображения. То есть
       применительно к исходному коду справедливо следующее:

       ```cpp
       0 <= ix && ix < src.cols - 1
       0 <= iy && iy < src.rows - 1
       ```

<!-- LINKS -->

[upstream]:        https://github.com/itseez-academy/itseez-ws-2016-practice
[git-update]:      https://github.com/itseez-academy/itseez-ws-2016-practice/blob/master/docs/practice2-profiling-and-benchmarking.md#Получение-актуальной-версии-исходных-файлов
[collect-metrics]: https://github.com/itseez-academy/itseez-ws-2016-practice/blob/master/docs/practice3-memory.md#Сбор-первоначальных-метрик-производительности
[feedback_day4]:   https://docs.google.com/forms/d/1s2CBJudCw_u-ws-Rzc0drC9sAi6Ham3-9fOWuTtMjBQ/viewform
